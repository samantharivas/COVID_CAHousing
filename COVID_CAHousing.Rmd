---
title: "COVID_CAHOUSING"
output: pdf_document
date: "2023-11-16"
---
Data Source: The data was sources from the Califronia Association of Realtors website. <https://www.car.org/marketdata/data/housingdata>. The data contains the median price of existing single-family detached homes in California, ranging from january 1990 until SEotember 2023. 

```{r setup}
library(tidyverse)
library(fpp3)
library(gridExtra)
library(ggplot2)
library(tsibble)
library(forecast)
library(patchwork)
library(fable)
library(readxl)
library(moments)
library(imputeTS)
library(zoo)
library(TTR)
```
# Importing Data 
```{r}
# import excel file 
home_prices <- read_excel("MedianPricesofExistingDetachedHomesHistoricalData.xlsx", skip = 6) |>
  mutate(`Mon-Yr` = as.Date(`Mon-Yr`, format = "%Y-%m")) |>
  as_tsibble(index = "Mon-Yr") # create tsibble 

# plot ts object 
autoplot(home_prices, CA) + 
  theme_minimal() 
```

```{r}
# check dimension of df 
dim(home_prices)
home_prices
```


```{r}
# specify the columns to convert to numeric
cols_to_convert <- c("Amador", "Calaveras", "Contra-Costa", "Del Norte", "El Dorado", "Glenn", "Kings", "Lake", 
                   "Lassen", "Madera", "Mariposa", "Nevada", "Plumas", "San Benito", "San Mateo", 
                   "Shasta", "Siskiyou", "Solano", "Stanislaus", "Sutter", "Tehama", "Trinity", 
                   "Tuolumne", "Monterey", "Mono", "Santa Cruz", "San Luis Obispo", 
                   "San Benito", "San Mateo", "Shasta", "Siskiyou", "Solano", "Sonoma", "Stanislaus", 
                   "Sutter", "Tehama", "Trinity", "Tulare", "Ventura", "Yolo", "Yuba", "Condo", 
                   "LA Metro", "Central Coast", "Central Valley", "Far North", "Inland Empire", 
                   "S.F. Bay Area", "SoCal", "Mendocino", "San Joaquin")

# convert columns to numeric
for (col in cols_to_convert) {
  home_prices[[col]] <- as.numeric(as.character(home_prices[[col]]))
}

# check the structure of your data frame after conversion
str(home_prices)

```

```{r}
# convert date to MM/YYYY format
home_prices$date <- as.Date(home_prices$`Mon-Yr`, format = "%Y-%m-%d")
home_prices$date <- as.Date(home_prices$date, format ="%m %Y")

# create seperate column for month and year
home_prices <- home_prices %>%
  mutate(Month = month(date), Year = year(date))

# remove mon-yr column and ...55 column 
columns_to_keep <- setdiff(names(home_prices), c("Mon-Yr", "...55"))
home_prices <- home_prices[, columns_to_keep]

#view the updated data frame
print(home_prices)
str(home_prices)
```
```{r}
# make a subset df removing condo, LA metro, Central Coast, Central Valley, Far North, Inland Empire, and S.F. Bay Area 
regions_to_exclude <- c("Condo", "LA Metro", "Central Coast", "Central Valley", "Far North", "Inland Empire", "S.F. Bay Area", "SoCal")

home_prices <- home_prices[, !(colnames(home_prices) %in% regions_to_exclude)]
```
```{r}
#check for duplicates
sum(duplicated(home_prices))
```

```{r}
#identify outliers using boxplot
par(mfrow = c(2, 4))

# Exclude the "Mon-Yr" column
numeric_columns <- names(home_prices)[sapply(home_prices, is.numeric) & names(home_prices) != "Mon-Yr"]

for (col in numeric_columns) {
  boxplot(home_prices[[col]],
          xlab = col,
          main = paste(col, "Boxplot"))
}

for (col in numeric_columns) {
  hist(home_prices[[col]],
          xlab = col,
          main = paste(col, "Histogram"))
}

```


```{r}
# check for missing values 
missing_values <- colSums(is.na(home_prices))
print(missing_values)

# check missing percentage of values per column
missing_percentage <- colMeans(is.na(home_prices)) * 100
missing_percentage <- missing_percentage[order(-missing_percentage)]
missing_percentage
```

We decided to drop columns whos data was more than 15% missing to maintain data integrity. 

```{r}
# Identify columns with more than 50% missing values
columns_to_drop <- names(missing_percentage[missing_percentage > 15])

# Print columns with more than 15% missing values
cat("Columns with More than 15% Missing Values:\n")
cat(columns_to_drop, sep = ", ")

# Drop the identified columns with more than 50% missing values from the DataFrame
home_prices <- home_prices[, !(names(home_prices) %in% columns_to_drop)]

```

```{r}
# use imputer to fill missing value with median 
home_prices_imp <- home_prices %>%
  mutate(across(-date, ~ifelse(is.na(.), mean(., na.rm = TRUE), .)))

# exclude non-numeric columns 
numeric_columns_imp <- home_prices_imp[sapply(home_prices_imp, is.numeric)] 

# calculate skewness for all numeric imputed variables
skewness_values_imp <- moments::skewness(numeric_columns_imp, na.rm = TRUE)

print(skewness_values_imp)
```
```{r}
# calculate skewness of original df 
# exclude non-numeric columns 
numeric_columns <- home_prices[sapply(home_prices, is.numeric)] 

# calculate skewness for all numeric variables
skewness_values <- moments::skewness(numeric_columns, na.rm = TRUE)

print(skewness_values)
```

```{r}
# compare skewness before and after 
skewness_all <- data.frame(
  Original_Skewness = skewness_values,
  Skewness_Imputed= skewness_values_imp
)

skewness_all
```
```{r}
summary(home_prices_imp)
```
```{r}
home_prices_imp

str(home_prices_imp)
```
```{r}
# subset data to be numeric only
#numeric_columns_imp <- home_prices_imp[sapply(home_prices_imp, is.numeric)]
#numeric_home_prices <- home_prices_imp[, numeric_columns]

# Calculate correlation matrix
#correlation <- cor(numeric_home_prices)
#library(corrplot)
#corrplot(correlation, order = "hclust", method = "color", addrect = 2)

#correlation
```

```{r}
# decompose ts 
# Decompose the time series 
decomposed <- decompose(ts(home_prices_imp$CA, frequency = 12))

autoplot(decomposed) +
  labs(title = "Seasonal Decomposition")


#stl_decomposed <- stl(home_prices_imp, s.window = "periodic")
#autoplot(stl_decomposed)
```
```{r}
# Plot the decomposed components
plot(decomposed$seasonal, main = "Seasonal Component")
```
```{r}
plot(decomposed$trend, main = "Seasonal Component")
```

```{r}
ACF <- acf(home_prices_imp, lag.max = 50)
```

```{r}
ACF <- acf(home_prices_imp$CA, lag.max = 50)
pacf <- pacf(home_prices_imp$CA)
```
```{r}
#simple moving average calculation
home_prices_imp$MA <- zoo::rollapply(home_prices_imp$CA, width = 4, FUN = mean, fill = NA)

ggplot(home_prices_imp, aes(x = Year)) +
  geom_line(aes(y = CA, color = "Actual Sales")) +
  geom_line(aes(y = MA, color = "MA")) +
  labs(title = "", x = "Year", y = "")+
  scale_color_manual(values = c("Actual Sales" = "blue", "MA" = "red")) + 
  theme_minimal()
```

```{r}
# convert df into ts 
ts_data <- ts(home_prices_imp, frequency = 12)

correlation_matrix <- cor(ts_data, use = "pairwise.complete.obs")
correlation_matrix
```

```{r}
# rename df 
CA <- home_prices_imp

CA
```
```{r}
CA_ts <- ts(CA$CA, frequency = 12, start = c(1990, 1), end = c(2023, 9))
```

```{r}
home_prices.lm <- tslm(CA_ts ~ trend + I(trend^2))
par(mfrow = c(2,1))
plot(CA_ts, xlab = "Time", ylab = "Shipments", ylim = c(160000 , 900000), bty = "l")
lines(home_prices.lm$fitted, lwd = 2)
CA_ts_zoom <- window(CA_ts, start = c(1990, 1), end = c(2023, 9))
plot(CA_ts_zoom, xlab = "Year", ylab = "CA", ylim = c(160000 , 900000), bty = "l")
```
# Modeling

```{r}
# Create 2 Partitions

# Training set is from January 1990 - December 2019
# Validation set is from January 2020 - September 2023
train <- window(CA_ts, start = c(1990, 1), end = c(2019, 12))
validation <- window(CA_ts, start = c(2020, 1))
```

```{r}
autoplot(train) + 
  autolayer(validation, color = "blue")
```

```{r}
# Naive Model
n_model <- naive(train, h = 5, level = 95)
```


```{r}
# plot the Naive Model - Training set
autoplot(train) + 
  autolayer(n_model, color = "red", series = "Naive") +
   autolayer(validation, color = "blue", series = "Actual")

```

```{r}
# Seasonal Naive Model
sn_model <- snaive(train, h = 5)
```


```{r}
# plot the snaive Model - Training set
autoplot(train) + 
  autolayer(sn_model, color = "red", series = "Seasonal Naive") +
   autolayer(validation, color = "blue", series = "Actual")

```

```{r}
# Season and Trend
st_model <- tslm(train ~ trend + season)

summary(st_model)
```

```{r}
st_forecast <- forecast(st_model, h=5)
st_forecast
```

```{r}
# plot the Season and Trend Model
autoplot(train) + 
  autolayer(st_forecast, color = "red", series = "season trend") +
   autolayer(validation, color = "blue", series = "Actual")

```


```{r}
# Determining the Error
accuracy(st_forecast)
accuracy(n_model)
accuracy(sn_model)
```

```{r}
mean(abs(n_model$residuals), na.rm = T) 
```

```{r}
sqrt(mean(n_model$residuals^2, na.rm = T)) 
```

